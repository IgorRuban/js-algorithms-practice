// Задача №18:
// Удалить повторяющиеся символы подряд

// Алгоритм:
// 1. Проверить — строка пустая? → вернуть ""
// 2. Создать пустую строку для результата
// 3. Пройти по каждому символу
// 4. Сравнить текущий символ с ПРЕДЫДУЩИМ
//    - Если они РАЗНЫЕ → добавить в результат
//    - Если они ОДИНАКОВЫЕ → пропустить
// 5. Вернуть результат

// Способ 1: for
const removeDuplicatesFor = (str) => {
  // Шаг 1: проверяем пустую строку
  // если строка пустая — нечего обрабатывать
  if (str.length === 0) return '';

  // Шаг 2: создаём пустую строку для результата
  let result = '';

  // Шаг 3: идём по каждому символу через индекс
  for (let i = 0; i < str.length; i++) {
    // Шаг 4: сравниваем текущий символ с предыдущим
    // str[i]     — текущий символ
    // str[i - 1] — предыдущий символ
    // когда i=0: str[-1] = undefined, 'a' !== undefined → true
    // поэтому первый символ всегда добавляется ✅
    if (str[i] !== str[i - 1]) {
      // Шаг 5: символы разные — добавляем в результат
      result += str[i];
    }
    // если символы одинаковые — просто пропускаем
  }
  // Шаг 6: возвращаем строку без подряд идущих дубликатов
  return result;
};

// Способ 2: for...of
const removeDuplicatesForOf = (str) => {
  // Шаг 1: пустая строка — возвращаем пустую строку
  if (str.length === 0) return '';

  // Шаг 2: создаём пустую строку для результата
  let result = '';

  // Шаг 3: for...of даёт сразу символ, без индекса
  // чище и читабельнее чем классический for
  for (const char of str) {
    // Шаг 4: сравниваем текущий символ с ПОСЛЕДНИМ символом result
    // result[result.length - 1] — последний добавленный символ
    // когда result = '' → result[-1] = undefined
    // 'a' !== undefined → true → первый символ всегда добавится ✅
    if (char !== result[result.length - 1]) {
      // Шаг 5: символы разные — добавляем в результат
      result += char;
    }
    // если символы одинаковые — пропускаем
  }
  // Шаг 6: возвращаем строку без подряд идущих дубликатов
  return result;
};

// Способ 3: filter()
const removeDuplicatesFilter = (str) => {
  // Шаг 1: пустая строка — возвращаем пустую строку
  if (str.length === 0) return '';

  // Шаг 2: вспомогательная переменная для отслеживания
  // последнего добавленного символа
  let result = '';

  return (
    str
      // Шаг 3: разбиваем строку в массив символов
      // "aabbcc" → ['a','a','b','b','c','c']
      .split('')

      // Шаг 4: filter оставляет только нужные символы
      .filter((char) => {
        // Шаг 5: сравниваем текущий символ с последним в result
        if (char !== result[result.length - 1]) {
          // Шаг 6: символы разные — обновляем result и оставляем символ
          result += char; // обновляем для следующей итерации
          return true; // символ остаётся в массиве
        }
        return false; // символ убирается из массива
      })

      // Шаг 7: собираем массив обратно в строку
      // ['a','b','c'] → "abc"
      .join('')
  );
};
// filter() обычно не имеет побочных эффектов
// но здесь мы намеренно обновляем result внутри filter
// это называется "side effect" — в реальном коде
// лучше использовать reduce() для таких случаев

// Способ 3: reduce()
const removeDuplicatesReduce = (str) => {
  // Шаг 1: пустая строка — возвращаем пустую строку
  if (str.length === 0) return '';

  return (
    str
      // Шаг 2: разбиваем строку в массив символов
      // "aabbcc" → ['a','a','b','b','c','c']
      .split('')

      // Шаг 3: reduce идёт по каждому символу
      // acc — накопитель (начинается с '')
      // char — текущий символ
      .reduce((acc, char) => {
        // Шаг 4: тернарный оператор:
        // если текущий символ ОТЛИЧАЕТСЯ от последнего в acc
        // → добавляем char
        // если ОДИНАКОВЫЙ → добавляем пустую строку (ничего)
        acc += char !== acc[acc.length - 1] ? char : '';

        // Шаг 5: возвращаем обновлённый накопитель
        return acc;
      }, '') // '' — начальное значение accumulator
  );
};

// Способ 6: Array.from()
const removeDuplicatesArrayFrom = (str) => {
  // Шаг 1: пустая строка — возвращаем пустую строку
  if (str.length === 0) return '';

  // Шаг 2: Array.from() конвертирует строку в массив символов
  // Array.from("aabbcc") → ['a','a','b','b','c','c']
  // аналог split('') но более современный синтаксис
  return (
    Array.from(str)

      // Шаг 3: reduce идёт по каждому символу
      // acc — накопитель (начинается с '')
      // char — текущий символ
      .reduce((acc, char) => {
        // Шаг 4: текущий символ отличается от последнего в acc?
        if (char !== acc[acc.length - 1]) {
          // Шаг 5: символы разные — добавляем в накопитель
          acc += char;
        }
        // Шаг 6: ВСЕГДА возвращаем acc
        // если символы одинаковые — возвращаем acc без изменений
        return acc;
      }, '')
  ); // '' — начальное значение accumulator
};

// 1. for — индекс i, сравниваем str[i] с str[i-1]
// 2. for...of — нет индекса, сравниваем с result[result.length-1]
// 3. filter() — split + filter (side effect) + join
// 4. reduce() — split + reduce (чисто, acc накопитель) + join не нужен
// 5. Array.from() — Array.from + reduce (современный синтаксис)

// Примеры:
// console.log(removeDuplicatesArrayFrom('')); //false
// console.log(removeDuplicatesArrayFrom('aabbcc')); // "abc"
// console.log(removeDuplicatesArrayFrom('aaabbbcc')); // "abc"
// console.log(removeDuplicatesArrayFrom('abcd')); // "abcd" (нет повторений)
// console.log(removeDuplicatesArrayFrom('aabbaabb')); // "abab"
// console.log(removeDuplicatesArrayFrom('aaaa')); // "a"
